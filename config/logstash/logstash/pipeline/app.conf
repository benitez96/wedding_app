input {
  # Logs de Caddy - Acceso público
  file {
    path => "/var/log/caddy/public_access.log"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/sincedb-caddy-public"
    codec => json { }
    tags => ["caddy", "public"]
  }
  
  # Logs de Caddy - Acceso a monitoreo
  file {
    path => "/var/log/caddy/monitoring_access.log"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/sincedb-caddy-monitoring"
    codec => json { }
    tags => ["caddy", "monitoring"]
  }
  
  # Logs de fail2ban
  file {
    path => "/var/log/fail2ban.log"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/sincedb-fail2ban"
    tags => ["fail2ban"]
  }
}

filter {
  # Agregar campos útiles para el análisis
  mutate {
    add_field => { "service" => "caddy" }
    add_field => { "environment" => "production" }
  }
  
  # Procesar logs de fail2ban
  if "fail2ban" in [tags] {
    grok {
      match => { 
        "message" => "%{SYSLOGTIMESTAMP:timestamp} %{SYSLOGFACILITY} %{DATA:program}\[%{NUMBER:pid}\]: %{GREEDYDATA:fail2ban_message}" 
      }
    }
    
    # Extraer información de baneo
    if [fail2ban_message] =~ /Ban\s+(\d+\.\d+\.\d+\.\d+)/ {
      grok {
        match => { "fail2ban_message" => "Ban\s+%{IP:ban_ip}" }
      }
    }
    
    if [fail2ban_message] =~ /Unban\s+(\d+\.\d+\.\d+\.\d+)/ {
      grok {
        match => { "fail2ban_message" => "Unban\s+%{IP:unban_ip}" }
      }
    }
    
    # Extraer jail name
    if [fail2ban_message] =~ /jail\s+([^\s]+)/ {
      grok {
        match => { "fail2ban_message" => ".*jail\s+%{DATA:jail_name}.*" }
      }
    }
  }
  
  # Procesar logs de Caddy
  if "caddy" in [tags] {
    # Parsear la URL para extraer información útil
    if [request] {
      grok {
        match => { "request" => "%{WORD:method} %{URIPATH:path} %{DATA:http_version}" }
      }
    }
    
    # Extraer información del User-Agent
    if [user_agent] {
      useragent {
        source => "user_agent"
        target => "user_agent_info"
      }
    }
    
    # Categorizar las rutas
    if [path] {
      mutate {
        add_field => {
          "route_category" => "%{[path]}"
        }
      }
      
      # Categorizar rutas específicas
      if [path] =~ "^/api/" {
        mutate {
          replace => { "route_category" => "api" }
        }
      } else if [path] =~ "^/backoffice/" {
        mutate {
          replace => { "route_category" => "admin" }
        }
      } else if [path] =~ "^/r/" {
        mutate {
          replace => { "route_category" => "invitation" }
        }
      } else if [path] =~ "\.(css|js|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$" {
        mutate {
          replace => { "route_category" => "static" }
        }
      } else {
        mutate {
          replace => { "route_category" => "page" }
        }
      }
    }
    
    # Agregar timestamp si no existe
    if ![timestamp] {
      date {
        match => [ "ts", "ISO8601" ]
        target => "timestamp"
        timezone => "America/Argentina/Buenos_Aires"
      }
    }
  }
  
  # Geolocalización se hará en Elasticsearch usando ingest pipeline
  # Esto es más seguro y eficiente que usar archivos locales
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "wedding-app-logs-%{+YYYY.MM.dd}"
    pipeline => "wedding-app-geoip"
  }
  stdout { codec => rubydebug }
}
